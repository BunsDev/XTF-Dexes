{
  "address": "0x6184DF20C2FD7515a102960C522C3431Fe0d8991",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "string[]",
          "name": "_providersHashes",
          "type": "string[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "lastUpdateTimestamp",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "providersHashes",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "reclaimAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "tokenSymbol",
          "type": "string"
        },
        {
          "internalType": "address",
          "name": "tokenAddress",
          "type": "address"
        }
      ],
      "name": "setTokenAddress",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "str",
          "type": "string"
        }
      ],
      "name": "split",
      "outputs": [
        {
          "internalType": "string[]",
          "name": "",
          "type": "string[]"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "name": "tokenSymbolToAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "tokenSymbolToVerifiedTags",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "name": "tokenSymbolToVerifiedTagsMap",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "string",
                  "name": "provider",
                  "type": "string"
                },
                {
                  "internalType": "string",
                  "name": "parameters",
                  "type": "string"
                },
                {
                  "internalType": "string",
                  "name": "context",
                  "type": "string"
                }
              ],
              "internalType": "struct Claims.ClaimInfo",
              "name": "claimInfo",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "bytes32",
                      "name": "identifier",
                      "type": "bytes32"
                    },
                    {
                      "internalType": "address",
                      "name": "owner",
                      "type": "address"
                    },
                    {
                      "internalType": "uint32",
                      "name": "timestampS",
                      "type": "uint32"
                    },
                    {
                      "internalType": "uint32",
                      "name": "epoch",
                      "type": "uint32"
                    }
                  ],
                  "internalType": "struct Claims.CompleteClaimData",
                  "name": "claim",
                  "type": "tuple"
                },
                {
                  "internalType": "bytes[]",
                  "name": "signatures",
                  "type": "bytes[]"
                }
              ],
              "internalType": "struct Claims.SignedClaim",
              "name": "signedClaim",
              "type": "tuple"
            }
          ],
          "internalType": "struct Reclaim.Proof",
          "name": "proof",
          "type": "tuple"
        },
        {
          "internalType": "string",
          "name": "tokenSymbolTag",
          "type": "string"
        }
      ],
      "name": "verifyProof",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xe4240d552d0eb8a2c78bb81e654de0a520d336984cfb3136d4716b2f4e337e37",
  "receipt": {
    "to": null,
    "from": "0x2a1F5eB3e84e58e6F1e565306298B9dE1273f203",
    "contractAddress": "0x6184DF20C2FD7515a102960C522C3431Fe0d8991",
    "transactionIndex": 136,
    "gasUsed": "1178312",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x198611f10cc1637e3c333ffaeb12e88903942d19f2cadd637d4f1dd6c540f8e7",
    "transactionHash": "0xe4240d552d0eb8a2c78bb81e654de0a520d336984cfb3136d4716b2f4e337e37",
    "logs": [],
    "blockNumber": 6021602,
    "cumulativeGasUsed": "16217016",
    "status": 1,
    "byzantium": true
  },
  "args": [
    [
      "0x9db032812994aabd3f3d25635ab22336a699bf3cf9b9ef84e547bbd8f7d0ae25"
    ]
  ],
  "numDeployments": 1,
  "solcInputHash": "29a899ca400dd8313a66bde15cf4477a",
  "metadata": "{\"compiler\":{\"version\":\"0.8.4+commit.c7e474f2\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_providersHashes\",\"type\":\"string[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"lastUpdateTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"providersHashes\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reclaimAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"}],\"name\":\"split\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"tokenSymbolToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenSymbolToVerifiedTags\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"tokenSymbolToVerifiedTagsMap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"provider\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"parameters\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"context\",\"type\":\"string\"}],\"internalType\":\"struct Claims.ClaimInfo\",\"name\":\"claimInfo\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"timestampS\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"epoch\",\"type\":\"uint32\"}],\"internalType\":\"struct Claims.CompleteClaimData\",\"name\":\"claim\",\"type\":\"tuple\"},{\"internalType\":\"bytes[]\",\"name\":\"signatures\",\"type\":\"bytes[]\"}],\"internalType\":\"struct Claims.SignedClaim\",\"name\":\"signedClaim\",\"type\":\"tuple\"}],\"internalType\":\"struct Reclaim.Proof\",\"name\":\"proof\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"tokenSymbolTag\",\"type\":\"string\"}],\"name\":\"verifyProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/TaggingVerifier.sol\":\"TaggingVerifier\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\",\"keccak256\":\"0xa4d1d62251f8574deb032a35fc948386a9b4de74b812d4f545a1ac120486b48a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\",\"keccak256\":\"0xda898fa084aa1ddfdb346e6a40459e00a59d87071cce7c315a46d648dd71d0ba\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa1e8e83cd0087785df04ac79fb395d9f3684caeaf973d9e2c71caef723a3a5d6\",\"license\":\"MIT\"},\"@reclaimprotocol/verifier-solidity-sdk/contracts/Addresses.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * Reclaim's addresses\\n */\\n\\nlibrary Addresses {\\n    address public constant BASE_MAINNET =\\n        0xACE04E6DeB9567C1B8F37D113F2Da9E690Fc128d;\\n    address public constant BNB_MAINNET =\\n        0x1bbb0896aC6F4E32a89157C73Fb830325a441cb9;\\n    address public constant POLYGON_MAINNET =\\n        0xEA11e7aBC9E4260747C11b1B9A25F65364a35A27;\\n    address public constant ARBITRUM_MAINNET =\\n        0xe79A453bD088F4A58656b315a7C1f8Ea3473CCf1;\\n    address public constant OPTIMISM_MAINNET =\\n        0xe79A453bD088F4A58656b315a7C1f8Ea3473CCf1;\\n    address public constant OPTIMISM_GOERLI_TESTNET =\\n        0x2f0306D698685BEf7ff50745BFF7178F0d117ba8;\\n    address public constant LINEA_TESTNET =\\n        0xf223E215B2c9A2E5FE1B2971d5694684b2E734C1;\\n    address public constant PLOYGON_MUMBAI_TESTNET =\\n        0xd6534f52CEB3d0139b915bc0C3278a94687fA5C7;\\n}\\n\",\"keccak256\":\"0xf49a4f3a618ab2f9ca2c056aba700f689694f0dc0b8766906a6390a58cf7b380\",\"license\":\"MIT\"},\"@reclaimprotocol/verifier-solidity-sdk/contracts/BytesUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * Utilities for bytes manipulation & conversion\\n */\\nlibrary BytesUtils {\\n\\tfunction bytesToUInt(bytes memory data, uint offset) internal pure returns (uint) {\\n\\t\\trequire(offset + 4 <= data.length, \\\"Offset + 4 must be within data bounds\\\");\\n\\n\\t\\tuint32 result;\\n\\t\\tassembly {\\n\\t\\t\\t// Load the 32 bits (4 bytes) from the data at the given offset into the result variable\\n\\t\\t\\tresult := mload(add(add(data, 0x4), offset))\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n}\\n\",\"keccak256\":\"0x63e91fce26f8c68c00a9de9c79e590e507a03d8f19355278b4316d7468a965b0\",\"license\":\"MIT\"},\"@reclaimprotocol/verifier-solidity-sdk/contracts/Claims.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"./StringUtils.sol\\\";\\n\\n/**\\n * Library to assist with requesting,\\n * serialising & verifying credentials\\n */\\nlibrary Claims {\\n\\t/** Data required to describe a claim */\\n\\tstruct CompleteClaimData {\\n\\t\\tbytes32 identifier;\\n\\t\\taddress owner;\\n\\t\\tuint32 timestampS;\\n\\t\\tuint32 epoch;\\n\\t}\\n\\n\\tstruct ClaimInfo {\\n\\t\\tstring provider;\\n\\t\\tstring parameters;\\n\\t\\tstring context;\\n\\t}\\n\\n\\t/** Claim with signatures & signer */\\n\\tstruct SignedClaim {\\n\\t\\tCompleteClaimData claim;\\n\\t\\tbytes[] signatures;\\n\\t}\\n\\n\\t/**\\n\\t * Asserts that the claim is signed by the expected witnesses\\n\\t */\\n\\tfunction assertValidSignedClaim(\\n\\t\\tSignedClaim memory self,\\n\\t\\taddress[] memory expectedWitnessAddresses\\n\\t) internal pure {\\n\\t\\trequire(self.signatures.length > 0, \\\"No signatures\\\");\\n\\t\\taddress[] memory signedWitnesses = recoverSignersOfSignedClaim(self);\\n\\t\\tfor (uint256 i = 0; i < expectedWitnessAddresses.length; i++) {\\n\\t\\t\\tbool found = false;\\n\\t\\t\\tfor (uint256 j = 0; j < signedWitnesses.length; j++) {\\n\\t\\t\\t\\tif (signedWitnesses[j] == expectedWitnessAddresses[i]) {\\n\\t\\t\\t\\t\\tfound = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\trequire(found, \\\"Missing witness signature\\\");\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev recovers the signer of the claim\\n\\t */\\n\\tfunction recoverSignersOfSignedClaim(\\n\\t\\tSignedClaim memory self\\n\\t) internal pure returns (address[] memory) {\\n\\t\\tbytes memory serialised = serialise(self.claim);\\n\\t\\taddress[] memory signers = new address[](self.signatures.length);\\n\\t\\tfor (uint256 i = 0; i < self.signatures.length; i++) {\\n\\t\\t\\tsigners[i] = verifySignature(serialised, self.signatures[i]);\\n\\t\\t}\\n\\n\\t\\treturn signers;\\n\\t}\\n\\n\\t/**\\n\\t * @dev serialises the credential into a string;\\n\\t * the string is used to verify the signature\\n\\t *\\n\\t * the serialisation is the same as done by the TS library\\n\\t */\\n\\tfunction serialise(\\n\\t\\tCompleteClaimData memory self\\n\\t) internal pure returns (bytes memory) {\\n\\t\\treturn\\n\\t\\t\\tabi.encodePacked(\\n\\t\\t\\t\\tStringUtils.bytes2str(abi.encodePacked(self.identifier)),\\n\\t\\t\\t\\t\\\"\\\\n\\\",\\n\\t\\t\\t\\tStringUtils.address2str(self.owner),\\n\\t\\t\\t\\t\\\"\\\\n\\\",\\n\\t\\t\\t\\tStringUtils.uint2str(self.timestampS),\\n\\t\\t\\t\\t\\\"\\\\n\\\",\\n\\t\\t\\t\\tStringUtils.uint2str(self.epoch)\\n\\t\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev returns the address of the user that generated the signature\\n\\t */\\n\\tfunction verifySignature(\\n\\t\\tbytes memory content,\\n\\t\\tbytes memory signature\\n\\t) internal pure returns (address signer) {\\n\\t\\tbytes32 signedHash = keccak256(\\n\\t\\t\\tabi.encodePacked(\\n\\t\\t\\t\\t\\\"\\\\x19Ethereum Signed Message:\\\\n\\\",\\n\\t\\t\\t\\tStringUtils.uint2str(content.length),\\n\\t\\t\\t\\tcontent\\n\\t\\t\\t)\\n\\t\\t);\\n\\t\\treturn ECDSA.recover(signedHash, signature);\\n\\t}\\n\\n\\tfunction hashClaimInfo(ClaimInfo memory claimInfo) internal pure returns (bytes32) {\\n\\t\\tbytes memory serialised = abi.encodePacked(\\n\\t\\t\\tclaimInfo.provider,\\n\\t\\t\\t\\\"\\\\n\\\",\\n\\t\\t\\tclaimInfo.parameters,\\n\\t\\t\\t\\\"\\\\n\\\",\\n\\t\\t\\tclaimInfo.context\\n\\t\\t);\\n\\t\\treturn keccak256(serialised);\\n\\t}\\n}\\n\",\"keccak256\":\"0x87a41e75d358e86798456ad45e03446cde8f1519c8af17905f6c8b852a5f2da7\",\"license\":\"MIT\"},\"@reclaimprotocol/verifier-solidity-sdk/contracts/Random.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n// implementation from: https://stackoverflow.com/a/67332959\\n// Utils for random number generation\\nlibrary Random {\\n\\t/**\\n\\t * @dev generates a random number from the given seed\\n\\t * This will always return the same number for the same seed & block\\n\\t */\\n\\tfunction random(uint256 seed) internal view returns (uint) {\\n\\t\\treturn uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, seed)));\\n\\t}\\n}\\n\",\"keccak256\":\"0xa9741057f21ce63334586ff80b1fce32b08e9582e9064746711c1b45491594a5\",\"license\":\"MIT\"},\"@reclaimprotocol/verifier-solidity-sdk/contracts/Reclaim.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./Claims.sol\\\";\\nimport \\\"./Random.sol\\\";\\nimport \\\"./StringUtils.sol\\\";\\nimport \\\"./BytesUtils.sol\\\";\\n\\n// import \\\"hardhat/console.sol\\\";\\n\\n\\n/**\\n * Reclaim Beacon contract\\n */\\ncontract Reclaim {\\n\\tstruct Witness {\\n\\t\\t/** ETH address of the witness */\\n\\t\\taddress addr;\\n\\t\\t/** Host to connect to the witness */\\n\\t\\tstring host;\\n\\t}\\n\\n\\tstruct Epoch {\\n\\t\\t/** Epoch number */\\n\\t\\tuint32 id;\\n\\t\\t/** when the epoch changed */\\n\\t\\tuint32 timestampStart;\\n\\t\\t/** when the epoch will change */\\n\\t\\tuint32 timestampEnd;\\n\\t\\t/** Witnesses for this epoch */\\n\\t\\tWitness[] witnesses;\\n\\t\\t/**\\n\\t\\t * Minimum number of witnesses\\n\\t\\t * required to create a claim\\n\\t\\t * */\\n\\t\\tuint8 minimumWitnessesForClaimCreation;\\n\\t}\\n\\n\\tstruct Proof {\\n\\t\\tClaims.ClaimInfo claimInfo;\\n\\t\\tClaims.SignedClaim signedClaim;\\n\\t}\\n\\n\\t/** list of all epochs */\\n\\tEpoch[] public epochs;\\n\\n\\t/**\\n\\t * duration of each epoch.\\n\\t * is not a hard duration, but useful for\\n\\t * caching purposes\\n\\t * */\\n\\tuint32 public epochDurationS; // 1 day\\n\\n\\t/**\\n\\t * current epoch.\\n\\t * starts at 1, so that the first epoch is 1\\n\\t * */\\n\\tuint32 public currentEpoch;\\n\\n\\n\\tevent EpochAdded(Epoch epoch);\\n\\n\\taddress public owner;\\n\\n\\t/**\\n\\t * @notice Calls initialize on the base contracts\\n\\t *\\n\\t * @dev This acts as a constructor for the upgradeable proxy contract\\n\\t */\\n\\tconstructor() {\\n\\t\\tepochDurationS = 1 days;\\n\\t\\tcurrentEpoch = 0;\\n\\t\\towner = msg.sender;\\n\\t}\\n\\n\\tmodifier onlyOwner () {\\n\\t\\trequire(owner == msg.sender, \\\"Only Owner\\\");\\n\\t\\t_;\\n\\t}\\n\\t// epoch functions ---\\n\\n\\t/**\\n\\t * Fetch an epoch\\n\\t * @param epoch the epoch number to fetch;\\n\\t * pass 0 to fetch the current epoch\\n\\t */\\n\\tfunction fetchEpoch(uint32 epoch) public view returns (Epoch memory) {\\n\\t\\tif (epoch == 0) {\\n\\t\\t\\treturn epochs[epochs.length - 1];\\n\\t\\t}\\n\\t\\treturn epochs[epoch - 1];\\n\\t}\\n\\n\\t/**\\n\\t * Get the witnesses that'll sign the claim\\n\\t */\\n\\tfunction fetchWitnessesForClaim(\\n\\t\\tuint32 epoch,\\n\\t\\tbytes32 identifier,\\n\\t\\tuint32 timestampS\\n\\t) public view returns (Witness[] memory) {\\n\\t\\tEpoch memory epochData = fetchEpoch(epoch);\\n\\t\\tbytes memory completeInput = abi.encodePacked(\\n\\t\\t\\t// hex encode bytes\\n\\t\\t\\tStringUtils.bytes2str(\\n\\t\\t\\t\\t// convert bytes32 to bytes\\n\\t\\t\\t\\tabi.encodePacked(identifier)\\n\\t\\t\\t),\\n\\t\\t\\t\\\"\\\\n\\\",\\n\\t\\t\\tStringUtils.uint2str(epoch),\\n\\t\\t\\t\\\"\\\\n\\\",\\n\\t\\t\\tStringUtils.uint2str(epochData.minimumWitnessesForClaimCreation),\\n\\t\\t\\t\\\"\\\\n\\\",\\n\\t\\t\\tStringUtils.uint2str(timestampS)\\n\\t\\t);\\n\\t\\tbytes memory completeHash = abi.encodePacked(keccak256(completeInput));\\n\\n\\t\\tWitness[] memory witnessesLeftList = epochData.witnesses;\\n\\t\\tWitness[] memory selectedWitnesses = new Witness[](\\n\\t\\t\\tepochData.minimumWitnessesForClaimCreation\\n\\t\\t);\\n\\t\\tuint witnessesLeft = witnessesLeftList.length;\\n\\n\\t\\tuint byteOffset = 0;\\n\\t\\tfor (uint32 i = 0; i < epochData.minimumWitnessesForClaimCreation; i++) {\\n\\t\\t\\tuint randomSeed = BytesUtils.bytesToUInt(completeHash, byteOffset);\\n\\t\\t\\tuint witnessIndex = randomSeed % witnessesLeft;\\n\\t\\t\\tselectedWitnesses[i] = witnessesLeftList[witnessIndex];\\n\\t\\t\\t// remove the witness from the list of witnesses\\n\\t\\t\\t// we've utilised witness at index \\\"idx\\\"\\n\\t\\t\\t// we of course don't want to pick the same witness twice\\n\\t\\t\\t// so we remove it from the list of witnesses\\n\\t\\t\\t// and reduce the number of witnesses left to pick from\\n\\t\\t\\t// since solidity doesn't support \\\"pop()\\\" in memory arrays\\n\\t\\t\\t// we swap the last element with the element we want to remove\\n\\t\\t\\twitnessesLeftList[witnessIndex] = epochData.witnesses[witnessesLeft - 1];\\n\\t\\t\\tbyteOffset = (byteOffset + 4) % completeHash.length;\\n\\t\\t\\twitnessesLeft -= 1;\\n\\t\\t}\\n\\n\\t\\treturn selectedWitnesses;\\n\\t}\\n\\n\\t/**\\n\\t * Call the function to assert\\n\\t * the validity of several claims proofs\\n\\t */\\n\\tfunction verifyProof(Proof memory proof) public view {\\n\\t\\t// create signed claim using claimData and signature.\\n\\t\\trequire(proof.signedClaim.signatures.length > 0, \\\"No signatures\\\");\\n\\t\\tClaims.SignedClaim memory signed = Claims.SignedClaim(\\n\\t\\t\\tproof.signedClaim.claim,\\n\\t\\t\\tproof.signedClaim.signatures\\n\\t\\t);\\n\\n\\t\\t// check if the hash from the claimInfo is equal to the infoHash in the claimData\\n\\t\\tbytes32 hashed = Claims.hashClaimInfo(proof.claimInfo);\\n\\t\\trequire(proof.signedClaim.claim.identifier == hashed);\\n\\n\\t\\t// fetch witness list from fetchEpoch(_epoch).witnesses\\n\\t\\tWitness[] memory expectedWitnesses = fetchWitnessesForClaim(\\n\\t\\t\\tproof.signedClaim.claim.epoch,\\n\\t\\t\\tproof.signedClaim.claim.identifier,\\n\\t\\t\\tproof.signedClaim.claim.timestampS\\n\\t\\t);\\n\\t\\taddress[] memory signedWitnesses = Claims.recoverSignersOfSignedClaim(signed);\\n\\t\\t// check if the number of signatures is equal to the number of witnesses\\n\\t\\trequire(\\n\\t\\t\\tsignedWitnesses.length == expectedWitnesses.length,\\n\\t\\t\\t\\\"Number of signatures not equal to number of witnesses\\\"\\n\\t\\t);\\n\\n\\t\\t// Update awaited: more checks on whose signatures can be considered.\\n\\t\\tfor (uint256 i = 0; i < signed.signatures.length; i++) {\\n\\t\\t\\tbool found = false;\\n\\t\\t\\tfor (uint j = 0; j < expectedWitnesses.length; j++) {\\n\\t\\t\\t\\tif (signedWitnesses[i] == expectedWitnesses[j].addr) {\\n\\t\\t\\t\\t\\tfound = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\trequire(found, \\\"Signature not appropriate\\\");\\n\\t\\t}\\n\\n\\t\\t//@TODO: verify zkproof\\n\\t}\\n\\n\\t// admin functions ---\\n\\n\\t/**\\n\\t * @dev Add a new epoch\\n\\t */\\n\\tfunction addNewEpoch(\\n\\t\\tWitness[] calldata witnesses,\\n\\t\\tuint8 requisiteWitnessesForClaimCreate\\n\\t) external onlyOwner {\\n\\t\\tif (epochDurationS == 0) {\\n\\t\\t\\tepochDurationS = 1 days;\\n\\t\\t}\\n\\t\\tif (epochs.length > 0) {\\n\\t\\t\\tepochs[epochs.length - 1].timestampEnd = uint32(block.timestamp);\\n\\t\\t}\\n\\n\\t\\tcurrentEpoch += 1;\\n\\t\\tEpoch storage epoch = epochs.push();\\n\\t\\tepoch.id = currentEpoch;\\n\\t\\tepoch.timestampStart = uint32(block.timestamp);\\n\\t\\tepoch.timestampEnd = uint32(block.timestamp + epochDurationS);\\n\\t\\tepoch.minimumWitnessesForClaimCreation = requisiteWitnessesForClaimCreate;\\n\\n\\t\\tfor (uint256 i = 0; i < witnesses.length; i++) {\\n\\t\\t\\tepoch.witnesses.push(witnesses[i]);\\n\\t\\t}\\n\\n\\t\\temit EpochAdded(epochs[epochs.length - 1]);\\n\\t}\\n\\n\\t// internal code -----\\n\\n\\tfunction uintDifference(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\tif (a > b) {\\n\\t\\t\\treturn a - b;\\n\\t\\t}\\n\\n\\t\\treturn b - a;\\n\\t}\\n}\\n\",\"keccak256\":\"0x89fd2ee012072abfba091530919a3222310db98ffa8f3b13ca1d087c27620f65\",\"license\":\"MIT\"},\"@reclaimprotocol/verifier-solidity-sdk/contracts/StringUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * Utilities for string manipulation & conversion\\n */\\nlibrary StringUtils {\\n\\tfunction address2str(address x) internal pure returns (string memory) {\\n\\t\\tbytes memory s = new bytes(40);\\n\\t\\tfor (uint i = 0; i < 20; i++) {\\n\\t\\t\\tbytes1 b = bytes1(uint8(uint(uint160(x)) / (2 ** (8 * (19 - i)))));\\n\\t\\t\\tbytes1 hi = bytes1(uint8(b) / 16);\\n\\t\\t\\tbytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\\n\\t\\t\\ts[2 * i] = getChar(hi);\\n\\t\\t\\ts[2 * i + 1] = getChar(lo);\\n\\t\\t}\\n\\t\\treturn string(abi.encodePacked(\\\"0x\\\", s));\\n\\t}\\n\\n\\tfunction bytes2str(bytes memory buffer) internal pure returns (string memory) {\\n\\t\\t// Fixed buffer size for hexadecimal convertion\\n\\t\\tbytes memory converted = new bytes(buffer.length * 2);\\n\\t\\tbytes memory _base = \\\"0123456789abcdef\\\";\\n\\n\\t\\tfor (uint256 i = 0; i < buffer.length; i++) {\\n\\t\\t\\tconverted[i * 2] = _base[uint8(buffer[i]) / _base.length];\\n\\t\\t\\tconverted[i * 2 + 1] = _base[uint8(buffer[i]) % _base.length];\\n\\t\\t}\\n\\n\\t\\treturn string(abi.encodePacked(\\\"0x\\\", converted));\\n\\t}\\n\\n\\tfunction getChar(bytes1 b) internal pure returns (bytes1 c) {\\n\\t\\tif (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\\n\\t\\telse return bytes1(uint8(b) + 0x57);\\n\\t}\\n\\n\\tfunction bool2str(bool _b) internal pure returns (string memory _uintAsString) {\\n\\t\\tif (_b) {\\n\\t\\t\\treturn \\\"true\\\";\\n\\t\\t} else {\\n\\t\\t\\treturn \\\"false\\\";\\n\\t\\t}\\n\\t}\\n\\n\\tfunction uint2str(uint _i) internal pure returns (string memory _uintAsString) {\\n\\t\\tif (_i == 0) {\\n\\t\\t\\treturn \\\"0\\\";\\n\\t\\t}\\n\\t\\tuint j = _i;\\n\\t\\tuint len;\\n\\t\\twhile (j != 0) {\\n\\t\\t\\tlen++;\\n\\t\\t\\tj /= 10;\\n\\t\\t}\\n\\t\\tbytes memory bstr = new bytes(len);\\n\\t\\tuint k = len;\\n\\t\\twhile (_i != 0) {\\n\\t\\t\\tk = k - 1;\\n\\t\\t\\tuint8 temp = (48 + uint8(_i - (_i / 10) * 10));\\n\\t\\t\\tbytes1 b1 = bytes1(temp);\\n\\t\\t\\tbstr[k] = b1;\\n\\t\\t\\t_i /= 10;\\n\\t\\t}\\n\\t\\treturn string(bstr);\\n\\t}\\n\\n\\tfunction areEqual(\\n\\t\\tstring calldata _a,\\n\\t\\tstring storage _b\\n\\t) internal pure returns (bool) {\\n\\t\\treturn keccak256(abi.encodePacked((_a))) == keccak256(abi.encodePacked((_b)));\\n\\t}\\n\\n\\tfunction areEqual(string memory _a, string memory _b) internal pure returns (bool) {\\n\\t\\treturn keccak256(abi.encodePacked((_a))) == keccak256(abi.encodePacked((_b)));\\n\\t}\\n\\n\\tfunction toLower(string memory str) internal pure returns (string memory) {\\n\\t\\tbytes memory bStr = bytes(str);\\n\\t\\tbytes memory bLower = new bytes(bStr.length);\\n\\t\\tfor (uint i = 0; i < bStr.length; i++) {\\n\\t\\t\\t// Uppercase character...\\n\\t\\t\\tif ((uint8(bStr[i]) >= 65) && (uint8(bStr[i]) <= 90)) {\\n\\t\\t\\t\\t// So we add 32 to make it lowercase\\n\\t\\t\\t\\tbLower[i] = bytes1(uint8(bStr[i]) + 32);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbLower[i] = bStr[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn string(bLower);\\n\\t}\\n\\n\\tfunction substring(\\n\\t\\tstring memory str,\\n\\t\\tuint startIndex,\\n\\t\\tuint endIndex\\n\\t) internal pure returns (string memory) {\\n\\t\\tbytes memory strBytes = bytes(str);\\n\\t\\tbytes memory result = new bytes(endIndex - startIndex);\\n\\t\\tfor (uint i = startIndex; i < endIndex; i++) {\\n\\t\\t\\tresult[i - startIndex] = strBytes[i];\\n\\t\\t}\\n\\t\\treturn string(result);\\n\\t}\\n}\\n\",\"keccak256\":\"0x15feebafef16d4c74c043b39e652ddae0e121987ceca74b663f6a2d2d7ba8b4b\",\"license\":\"MIT\"},\"contracts/TaggingVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// pragma solidity 0.8.20;\\npragma solidity 0.8.4;\\n\\nimport \\\"@reclaimprotocol/verifier-solidity-sdk/contracts/Reclaim.sol\\\";\\nimport \\\"@reclaimprotocol/verifier-solidity-sdk/contracts/Addresses.sol\\\";\\n \\ncontract TaggingVerifier {\\n  address public reclaimAddress;\\n  // add providersHashes for your permitted providers\\n  string[] public providersHashes;\\n  mapping(string => address) public tokenSymbolToAddress;\\n  mapping(string => string[]) public tokenSymbolToVerifiedTags;\\n  mapping (string => mapping(string => bool)) public tokenSymbolToVerifiedTagsMap;\\n  uint256 public lastUpdateTimestamp;\\n\\n  constructor(string[] memory _providersHashes){\\n     providersHashes = _providersHashes;\\n     reclaimAddress = Addresses.PLOYGON_MUMBAI_TESTNET; \\n  }\\n\\n  function setTokenAddress(string memory tokenSymbol, address tokenAddress) public \\n  // onlyOwner\\n  {\\n    tokenSymbolToAddress[tokenSymbol] = tokenAddress;\\n  }\\n\\n  function split(string memory str) public pure returns (string[] memory) {\\n        bytes memory strBytes = bytes(str);\\n        uint256 count = 1;\\n        for (uint256 i = 0; i < strBytes.length; i++) {\\n            if (strBytes[i] == \\\",\\\") {\\n                count++;\\n            }\\n        }\\n        string[] memory result = new string[](count);\\n        uint256 j = 0;\\n        bytes memory temp;\\n        for (uint256 i = 0; i < strBytes.length; i++) {\\n            if (strBytes[i] == \\\",\\\") {\\n                result[j] = string(temp);\\n                j++;\\n                temp = \\\"\\\";\\n            } else {\\n                temp = abi.encodePacked(temp, strBytes[i]);\\n            }\\n        }\\n\\n        result[j] = string(temp);\\n        return result;\\n    }\\n\\n  function verifyProof(Reclaim.Proof memory proof, string memory tokenSymbolTag) public {\\n      Reclaim(reclaimAddress).verifyProof(proof);\\n      require(keccak256(abi.encodePacked(proof.claimInfo.parameters)) == keccak256(abi.encodePacked(tokenSymbolTag)), \\\"Invalid token list parameters\\\");\\n      string[] memory stringList = split(tokenSymbolTag);    \\n      require(stringList.length == 2, \\\"Invalid token list parameters\\\");\\n      if (tokenSymbolToVerifiedTags[stringList[0]].length == 0) {\\n          tokenSymbolToVerifiedTags[stringList[0]] = new string[](0);\\n      }\\n      tokenSymbolToVerifiedTags[stringList[0]].push(stringList[1]);\\n      tokenSymbolToVerifiedTagsMap[stringList[0]][stringList[1]] = true;\\n      lastUpdateTimestamp = block.timestamp;\\n  }\\n}\\n\",\"keccak256\":\"0x4b86df1b4a1dc7dc3a88aa4d94aca04cfdc6198f55c2b8748700df814662831d\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b506040516200157538038062001575833981016040819052620000349162000271565b80516200004990600190602084019062000077565b5050600080546001600160a01b03191673d6534f52ceb3d0139b915bc0c3278a94687fa5c7179055620003c6565b828054828255906000526020600020908101928215620000c9579160200282015b82811115620000c95782518051620000b8918491602090910190620000db565b509160200191906001019062000098565b50620000d792915062000166565b5090565b828054620000e99062000373565b90600052602060002090601f0160209004810192826200010d576000855562000158565b82601f106200012857805160ff191683800117855562000158565b8280016001018555821562000158579182015b82811115620001585782518255916020019190600101906200013b565b50620000d792915062000187565b80821115620000d75760006200017d82826200019e565b5060010162000166565b5b80821115620000d7576000815560010162000188565b508054620001ac9062000373565b6000825580601f10620001bd575050565b601f016020900490600052602060002090810190620001dd919062000187565b50565b600082601f830112620001f1578081fd5b81516001600160401b038111156200020d576200020d620003b0565b602062000223601f8301601f1916820162000340565b828152858284870101111562000237578384fd5b835b838110156200025657858101830151828201840152820162000239565b838111156200026757848385840101525b5095945050505050565b6000602080838503121562000284578182fd5b82516001600160401b03808211156200029b578384fd5b818501915085601f830112620002af578384fd5b815181811115620002c457620002c4620003b0565b8060051b620002d585820162000340565b8281528581019085870183870188018b1015620002f0578889fd5b8893505b8484101562000332578051868111156200030c57898afd5b6200031c8c8a838b0101620001e0565b84525060019390930192918701918701620002f4565b509998505050505050505050565b604051601f8201601f191681016001600160401b03811182821017156200036b576200036b620003b0565b604052919050565b600181811c908216806200038857607f821691505b60208210811415620003aa57634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052604160045260246000fd5b61119f80620003d66000396000f3fe608060405234801561001057600080fd5b50600436106100935760003560e01c8063713696da11610066578063713696da146100fc578063aeade0e614610148578063bb00ae4a1461015b578063bcbc53911461017b578063e500cdc8146101d657600080fd5b806314bcec9f1461009857806317456e56146100b45780632a7b2c93146100c957806334dff439146100e9575b600080fd5b6100a160055481565b6040519081526020015b60405180910390f35b6100c76100c2366004610c10565b6101e9565b005b6100dc6100d7366004610bd6565b61022d565b6040516100ab9190610e96565b6100c76100f7366004610cfd565b61042d565b61013061010a366004610bd6565b80516020818301810180516002825292820191909301209152546001600160a01b031681565b6040516001600160a01b0390911681526020016100ab565b600054610130906001600160a01b031681565b61016e610169366004610cbb565b6107a2565b6040516100ab9190610ef7565b6101c6610189366004610c5b565b8151602081840181018051600482529282019482019490942091909352815180830184018051928152908401929093019190912091525460ff1681565b60405190151581526020016100ab565b61016e6101e4366004610e07565b61086a565b806002836040516101fa9190610e7a565b90815260405190819003602001902080546001600160a01b03929092166001600160a01b03199092169190911790555050565b606081600160005b82518110156102995782818151811061025e57634e487b7160e01b600052603260045260246000fd5b6020910101516001600160f81b031916600b60fa1b141561028757816102838161112c565b9250505b806102918161112c565b915050610235565b506000816001600160401b038111156102c257634e487b7160e01b600052604160045260246000fd5b6040519080825280602002602001820160405280156102f557816020015b60608152602001906001900390816102e05790505b5090506000606060005b85518110156103f55785818151811061032857634e487b7160e01b600052603260045260246000fd5b6020910101516001600160f81b031916600b60fa1b1415610394578184848151811061036457634e487b7160e01b600052603260045260246000fd5b6020026020010181905250828061037a9061112c565b9350506040518060200160405280600081525091506103e3565b818682815181106103b557634e487b7160e01b600052603260045260246000fd5b602001015160f81c60f81b6040516020016103d1929190610e4b565b60405160208183030381529060405291505b806103ed8161112c565b9150506102ff565b508083838151811061041757634e487b7160e01b600052603260045260246000fd5b6020908102919091010152509095945050505050565b6000546040516354b0734f60e11b81526001600160a01b039091169063a960e69e9061045d908590600401610f11565b60006040518083038186803b15801561047557600080fd5b505afa158015610489573d6000803e3d6000fd5b505050508060405160200161049e9190610e7a565b60408051601f19818403018152908290528051602091820120845182015190926104c89201610e7a565b60405160208183030381529060405280519060200120146105305760405162461bcd60e51b815260206004820152601d60248201527f496e76616c696420746f6b656e206c69737420706172616d657465727300000060448201526064015b60405180910390fd5b600061053b8261022d565b9050805160021461058e5760405162461bcd60e51b815260206004820152601d60248201527f496e76616c696420746f6b656e206c69737420706172616d65746572730000006044820152606401610527565b6003816000815181106105b157634e487b7160e01b600052603260045260246000fd5b60200260200101516040516105c69190610e7a565b90815260405190819003602001902054610661576040805160008082526020820190925290610605565b60608152602001906001900390816105f05790505b5060038260008151811061062957634e487b7160e01b600052603260045260246000fd5b602002602001015160405161063e9190610e7a565b9081526020016040518091039020908051906020019061065f929190610895565b505b60038160008151811061068457634e487b7160e01b600052603260045260246000fd5b60200260200101516040516106999190610e7a565b9081526020016040518091039020816001815181106106c857634e487b7160e01b600052603260045260246000fd5b602090810291909101810151825460018101845560009384529282902081516106fa94919091019291909101906108f2565b50600160048260008151811061072057634e487b7160e01b600052603260045260246000fd5b60200260200101516040516107359190610e7a565b90815260200160405180910390208260018151811061076457634e487b7160e01b600052603260045260246000fd5b60200260200101516040516107799190610e7a565b908152604051908190036020019020805491151560ff1990921691909117905550504260055550565b815160208184018101805160038252928201918501919091209190528054829081106107cd57600080fd5b906000526020600020016000915091505080546107e9906110f1565b80601f0160208091040260200160405190810160405280929190818152602001828054610815906110f1565b80156108625780601f1061083757610100808354040283529160200191610862565b820191906000526020600020905b81548152906001019060200180831161084557829003601f168201915b505050505081565b6001818154811061087a57600080fd5b9060005260206000200160009150905080546107e9906110f1565b8280548282559060005260206000209081019282156108e2579160200282015b828111156108e257825180516108d29184916020909101906108f2565b50916020019190600101906108b5565b506108ee929150610972565b5090565b8280546108fe906110f1565b90600052602060002090601f0160209004810192826109205760008555610966565b82601f1061093957805160ff1916838001178555610966565b82800160010185558215610966579182015b8281111561096657825182559160200191906001019061094b565b506108ee92915061098f565b808211156108ee57600061098682826109a4565b50600101610972565b5b808211156108ee5760008155600101610990565b5080546109b0906110f1565b6000825580601f106109c0575050565b601f0160209004906000526020600020908101906109de919061098f565b50565b80356001600160a01b03811681146109f857600080fd5b919050565b600082601f830112610a0d578081fd5b813560206001600160401b0380831115610a2957610a29611153565b8260051b610a38838201611091565b8481528381019087850183890186018a1015610a52578788fd5b8793505b86841015610a8f57803585811115610a6c578889fd5b610a7a8b88838d0101610a9c565b84525060019390930192918501918501610a56565b5098975050505050505050565b600082601f830112610aac578081fd5b81356001600160401b03811115610ac557610ac5611153565b610ad8601f8201601f1916602001611091565b818152846020838601011115610aec578283fd5b816020850160208301379081016020019190915292915050565b600081830360a0811215610b18578182fd5b604051604081016001600160401b038282108183111715610b3b57610b3b611153565b816040528294506080841215610b5057600080fd5b610b58611025565b935085358452610b6a602087016109e1565b6020850152610b7b60408701610bc2565b6040850152610b8c60608701610bc2565b606085015292825260808501359280841115610ba757600080fd5b5050610bb5858386016109fd565b6020820152505092915050565b803563ffffffff811681146109f857600080fd5b600060208284031215610be7578081fd5b81356001600160401b03811115610bfc578182fd5b610c0884828501610a9c565b949350505050565b60008060408385031215610c22578081fd5b82356001600160401b03811115610c37578182fd5b610c4385828601610a9c565b925050610c52602084016109e1565b90509250929050565b60008060408385031215610c6d578182fd5b82356001600160401b0380821115610c83578384fd5b610c8f86838701610a9c565b93506020850135915080821115610ca4578283fd5b50610cb185828601610a9c565b9150509250929050565b60008060408385031215610ccd578182fd5b82356001600160401b03811115610ce2578283fd5b610cee85828601610a9c565b95602094909401359450505050565b60008060408385031215610d0f578182fd5b82356001600160401b0380821115610d25578384fd5b9084019060408287031215610d38578384fd5b610d4061104d565b823582811115610d4e578586fd5b830160608189031215610d5f578586fd5b610d6761106f565b813584811115610d75578788fd5b610d818a828501610a9c565b825250602082013584811115610d95578788fd5b610da18a828501610a9c565b602083015250604082013584811115610db8578788fd5b610dc48a828501610a9c565b604083015250825250602083013582811115610dde578586fd5b610dea88828601610b06565b602083015250809450506020850135915080821115610ca4578283fd5b600060208284031215610e18578081fd5b5035919050565b60008151808452610e378160208601602086016110c1565b601f01601f19169290920160200192915050565b60008351610e5d8184602088016110c1565b6001600160f81b0319939093169190920190815260010192915050565b60008251610e8c8184602087016110c1565b9190910192915050565b6000602080830181845280855180835260408601915060408160051b8701019250838701855b82811015610eea57603f19888603018452610ed8858351610e1f565b94509285019290850190600101610ebc565b5092979650505050505050565b602081526000610f0a6020830184610e1f565b9392505050565b6000602080835283516040828501528051606080860152610f3560c0860182610e1f565b905082820151605f1980878403016080880152610f528383610e1f565b925060408401519350808784030160a08801525050610f718183610e1f565b83870151601f1987830301604080890191909152815180518452808701516001600160a01b0316848801528082015163ffffffff908116928501929092526060908101519091169083015284015160a06080830181905281519083018190529193508401915060c0600582901b840181019190840190865b818110156110175760bf19868503018352611005848651610e1f565b94870194935091860191600101610fe9565b509198975050505050505050565b604051608081016001600160401b038111828210171561104757611047611153565b60405290565b604080519081016001600160401b038111828210171561104757611047611153565b604051606081016001600160401b038111828210171561104757611047611153565b604051601f8201601f191681016001600160401b03811182821017156110b9576110b9611153565b604052919050565b60005b838110156110dc5781810151838201526020016110c4565b838111156110eb576000848401525b50505050565b600181811c9082168061110557607f821691505b6020821081141561112657634e487b7160e01b600052602260045260246000fd5b50919050565b600060001982141561114c57634e487b7160e01b81526011600452602481fd5b5060010190565b634e487b7160e01b600052604160045260246000fdfea2646970667358221220ae9e9d8ed2160035bf98e8c09c6d1e680f2dfdb7e999a94141a05bc4d9e4b70464736f6c63430008040033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100935760003560e01c8063713696da11610066578063713696da146100fc578063aeade0e614610148578063bb00ae4a1461015b578063bcbc53911461017b578063e500cdc8146101d657600080fd5b806314bcec9f1461009857806317456e56146100b45780632a7b2c93146100c957806334dff439146100e9575b600080fd5b6100a160055481565b6040519081526020015b60405180910390f35b6100c76100c2366004610c10565b6101e9565b005b6100dc6100d7366004610bd6565b61022d565b6040516100ab9190610e96565b6100c76100f7366004610cfd565b61042d565b61013061010a366004610bd6565b80516020818301810180516002825292820191909301209152546001600160a01b031681565b6040516001600160a01b0390911681526020016100ab565b600054610130906001600160a01b031681565b61016e610169366004610cbb565b6107a2565b6040516100ab9190610ef7565b6101c6610189366004610c5b565b8151602081840181018051600482529282019482019490942091909352815180830184018051928152908401929093019190912091525460ff1681565b60405190151581526020016100ab565b61016e6101e4366004610e07565b61086a565b806002836040516101fa9190610e7a565b90815260405190819003602001902080546001600160a01b03929092166001600160a01b03199092169190911790555050565b606081600160005b82518110156102995782818151811061025e57634e487b7160e01b600052603260045260246000fd5b6020910101516001600160f81b031916600b60fa1b141561028757816102838161112c565b9250505b806102918161112c565b915050610235565b506000816001600160401b038111156102c257634e487b7160e01b600052604160045260246000fd5b6040519080825280602002602001820160405280156102f557816020015b60608152602001906001900390816102e05790505b5090506000606060005b85518110156103f55785818151811061032857634e487b7160e01b600052603260045260246000fd5b6020910101516001600160f81b031916600b60fa1b1415610394578184848151811061036457634e487b7160e01b600052603260045260246000fd5b6020026020010181905250828061037a9061112c565b9350506040518060200160405280600081525091506103e3565b818682815181106103b557634e487b7160e01b600052603260045260246000fd5b602001015160f81c60f81b6040516020016103d1929190610e4b565b60405160208183030381529060405291505b806103ed8161112c565b9150506102ff565b508083838151811061041757634e487b7160e01b600052603260045260246000fd5b6020908102919091010152509095945050505050565b6000546040516354b0734f60e11b81526001600160a01b039091169063a960e69e9061045d908590600401610f11565b60006040518083038186803b15801561047557600080fd5b505afa158015610489573d6000803e3d6000fd5b505050508060405160200161049e9190610e7a565b60408051601f19818403018152908290528051602091820120845182015190926104c89201610e7a565b60405160208183030381529060405280519060200120146105305760405162461bcd60e51b815260206004820152601d60248201527f496e76616c696420746f6b656e206c69737420706172616d657465727300000060448201526064015b60405180910390fd5b600061053b8261022d565b9050805160021461058e5760405162461bcd60e51b815260206004820152601d60248201527f496e76616c696420746f6b656e206c69737420706172616d65746572730000006044820152606401610527565b6003816000815181106105b157634e487b7160e01b600052603260045260246000fd5b60200260200101516040516105c69190610e7a565b90815260405190819003602001902054610661576040805160008082526020820190925290610605565b60608152602001906001900390816105f05790505b5060038260008151811061062957634e487b7160e01b600052603260045260246000fd5b602002602001015160405161063e9190610e7a565b9081526020016040518091039020908051906020019061065f929190610895565b505b60038160008151811061068457634e487b7160e01b600052603260045260246000fd5b60200260200101516040516106999190610e7a565b9081526020016040518091039020816001815181106106c857634e487b7160e01b600052603260045260246000fd5b602090810291909101810151825460018101845560009384529282902081516106fa94919091019291909101906108f2565b50600160048260008151811061072057634e487b7160e01b600052603260045260246000fd5b60200260200101516040516107359190610e7a565b90815260200160405180910390208260018151811061076457634e487b7160e01b600052603260045260246000fd5b60200260200101516040516107799190610e7a565b908152604051908190036020019020805491151560ff1990921691909117905550504260055550565b815160208184018101805160038252928201918501919091209190528054829081106107cd57600080fd5b906000526020600020016000915091505080546107e9906110f1565b80601f0160208091040260200160405190810160405280929190818152602001828054610815906110f1565b80156108625780601f1061083757610100808354040283529160200191610862565b820191906000526020600020905b81548152906001019060200180831161084557829003601f168201915b505050505081565b6001818154811061087a57600080fd5b9060005260206000200160009150905080546107e9906110f1565b8280548282559060005260206000209081019282156108e2579160200282015b828111156108e257825180516108d29184916020909101906108f2565b50916020019190600101906108b5565b506108ee929150610972565b5090565b8280546108fe906110f1565b90600052602060002090601f0160209004810192826109205760008555610966565b82601f1061093957805160ff1916838001178555610966565b82800160010185558215610966579182015b8281111561096657825182559160200191906001019061094b565b506108ee92915061098f565b808211156108ee57600061098682826109a4565b50600101610972565b5b808211156108ee5760008155600101610990565b5080546109b0906110f1565b6000825580601f106109c0575050565b601f0160209004906000526020600020908101906109de919061098f565b50565b80356001600160a01b03811681146109f857600080fd5b919050565b600082601f830112610a0d578081fd5b813560206001600160401b0380831115610a2957610a29611153565b8260051b610a38838201611091565b8481528381019087850183890186018a1015610a52578788fd5b8793505b86841015610a8f57803585811115610a6c578889fd5b610a7a8b88838d0101610a9c565b84525060019390930192918501918501610a56565b5098975050505050505050565b600082601f830112610aac578081fd5b81356001600160401b03811115610ac557610ac5611153565b610ad8601f8201601f1916602001611091565b818152846020838601011115610aec578283fd5b816020850160208301379081016020019190915292915050565b600081830360a0811215610b18578182fd5b604051604081016001600160401b038282108183111715610b3b57610b3b611153565b816040528294506080841215610b5057600080fd5b610b58611025565b935085358452610b6a602087016109e1565b6020850152610b7b60408701610bc2565b6040850152610b8c60608701610bc2565b606085015292825260808501359280841115610ba757600080fd5b5050610bb5858386016109fd565b6020820152505092915050565b803563ffffffff811681146109f857600080fd5b600060208284031215610be7578081fd5b81356001600160401b03811115610bfc578182fd5b610c0884828501610a9c565b949350505050565b60008060408385031215610c22578081fd5b82356001600160401b03811115610c37578182fd5b610c4385828601610a9c565b925050610c52602084016109e1565b90509250929050565b60008060408385031215610c6d578182fd5b82356001600160401b0380821115610c83578384fd5b610c8f86838701610a9c565b93506020850135915080821115610ca4578283fd5b50610cb185828601610a9c565b9150509250929050565b60008060408385031215610ccd578182fd5b82356001600160401b03811115610ce2578283fd5b610cee85828601610a9c565b95602094909401359450505050565b60008060408385031215610d0f578182fd5b82356001600160401b0380821115610d25578384fd5b9084019060408287031215610d38578384fd5b610d4061104d565b823582811115610d4e578586fd5b830160608189031215610d5f578586fd5b610d6761106f565b813584811115610d75578788fd5b610d818a828501610a9c565b825250602082013584811115610d95578788fd5b610da18a828501610a9c565b602083015250604082013584811115610db8578788fd5b610dc48a828501610a9c565b604083015250825250602083013582811115610dde578586fd5b610dea88828601610b06565b602083015250809450506020850135915080821115610ca4578283fd5b600060208284031215610e18578081fd5b5035919050565b60008151808452610e378160208601602086016110c1565b601f01601f19169290920160200192915050565b60008351610e5d8184602088016110c1565b6001600160f81b0319939093169190920190815260010192915050565b60008251610e8c8184602087016110c1565b9190910192915050565b6000602080830181845280855180835260408601915060408160051b8701019250838701855b82811015610eea57603f19888603018452610ed8858351610e1f565b94509285019290850190600101610ebc565b5092979650505050505050565b602081526000610f0a6020830184610e1f565b9392505050565b6000602080835283516040828501528051606080860152610f3560c0860182610e1f565b905082820151605f1980878403016080880152610f528383610e1f565b925060408401519350808784030160a08801525050610f718183610e1f565b83870151601f1987830301604080890191909152815180518452808701516001600160a01b0316848801528082015163ffffffff908116928501929092526060908101519091169083015284015160a06080830181905281519083018190529193508401915060c0600582901b840181019190840190865b818110156110175760bf19868503018352611005848651610e1f565b94870194935091860191600101610fe9565b509198975050505050505050565b604051608081016001600160401b038111828210171561104757611047611153565b60405290565b604080519081016001600160401b038111828210171561104757611047611153565b604051606081016001600160401b038111828210171561104757611047611153565b604051601f8201601f191681016001600160401b03811182821017156110b9576110b9611153565b604052919050565b60005b838110156110dc5781810151838201526020016110c4565b838111156110eb576000848401525b50505050565b600181811c9082168061110557607f821691505b6020821081141561112657634e487b7160e01b600052602260045260246000fd5b50919050565b600060001982141561114c57634e487b7160e01b81526011600452602481fd5b5060010190565b634e487b7160e01b600052604160045260246000fdfea2646970667358221220ae9e9d8ed2160035bf98e8c09c6d1e680f2dfdb7e999a94141a05bc4d9e4b70464736f6c63430008040033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 5029,
        "contract": "contracts/TaggingVerifier.sol:TaggingVerifier",
        "label": "reclaimAddress",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 5032,
        "contract": "contracts/TaggingVerifier.sol:TaggingVerifier",
        "label": "providersHashes",
        "offset": 0,
        "slot": "1",
        "type": "t_array(t_string_storage)dyn_storage"
      },
      {
        "astId": 5036,
        "contract": "contracts/TaggingVerifier.sol:TaggingVerifier",
        "label": "tokenSymbolToAddress",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_string_memory_ptr,t_address)"
      },
      {
        "astId": 5041,
        "contract": "contracts/TaggingVerifier.sol:TaggingVerifier",
        "label": "tokenSymbolToVerifiedTags",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_string_memory_ptr,t_array(t_string_storage)dyn_storage)"
      },
      {
        "astId": 5047,
        "contract": "contracts/TaggingVerifier.sol:TaggingVerifier",
        "label": "tokenSymbolToVerifiedTagsMap",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_string_memory_ptr,t_mapping(t_string_memory_ptr,t_bool))"
      },
      {
        "astId": 5049,
        "contract": "contracts/TaggingVerifier.sol:TaggingVerifier",
        "label": "lastUpdateTimestamp",
        "offset": 0,
        "slot": "5",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_string_storage)dyn_storage": {
        "base": "t_string_storage",
        "encoding": "dynamic_array",
        "label": "string[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_string_memory_ptr,t_address)": {
        "encoding": "mapping",
        "key": "t_string_memory_ptr",
        "label": "mapping(string => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_string_memory_ptr,t_array(t_string_storage)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_string_memory_ptr",
        "label": "mapping(string => string[])",
        "numberOfBytes": "32",
        "value": "t_array(t_string_storage)dyn_storage"
      },
      "t_mapping(t_string_memory_ptr,t_bool)": {
        "encoding": "mapping",
        "key": "t_string_memory_ptr",
        "label": "mapping(string => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_string_memory_ptr,t_mapping(t_string_memory_ptr,t_bool))": {
        "encoding": "mapping",
        "key": "t_string_memory_ptr",
        "label": "mapping(string => mapping(string => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_string_memory_ptr,t_bool)"
      },
      "t_string_memory_ptr": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}